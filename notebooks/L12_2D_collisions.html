
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Two-dimensional collisions &#8212; NAPS Intermediate Physics</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.c441f2ba0852f4cabcb80105e3a46ae6.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  
  <h1 class="site-logo" id="site-title">NAPS Intermediate Physics</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../README.html">
   NAPS Intermediate Physics
  </a>
 </li>
</ul>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="L01_Introduction_to_Python.html">
   1. Introduction to Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L02_Vectors_and_vPython.html">
   2. Vectors and vPython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L03_Velocity_and_Euler_method.html">
   3. Velocity and the Euler method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L03A_Units_and_scientific_notation.html">
   4. Units and scientific notation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L04_Acceleration_and_free_fall.html">
   5. Acceleration and free fall
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L05_Kinematic_equations.html">
   6. Kinematic equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L06_Vector_magnitude_and_direction.html">
   7. Vector magnitude and direction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L07_Projectile_motion.html">
   8. Projectile motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L10_Relative_motion.html">
   9. Relative motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L08_Linear_momentum_and_Newton%27s_laws_of_motion.html">
   10. Linear momentum and Newton's laws of motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L09_Center_of_mass_and_collisions.html">
   11. Center of mass and collisions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L13_Solving_force_problems.html">
   12. Solving force problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L11_Scalar_product.html">
   13. Scalar product
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L14_Inclined_planes.html">
   14. Inclined planes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L17_Fluids.html">
   15. Fluids
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L18_Circular_motion.html">
   16. Circular motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L19_Vector_product.html">
   17. Vector product
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L20_Angular_momentum.html">
   18. Angular momentum
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L23_Work_and_energy.html">
   19. Work and kinetic energy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L24_Conservation_of_energy.html">
   20. Conservation of energy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L25_Universal_gravitation.html">
   21. Universal gravitation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L26_Gravitational_potential_energy.html">
   22. Gravitational potential energy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L27_Kepler%27s_laws.html">
   23. Kepler's laws
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L28_Coulomb%27s_law.html">
   24. Coulomb's law
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L29_Electric_fields.html">
   25. Electric fields
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L34_Magnetic_fields_and_forces.html">
   26. Magnetic fields and forces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L35_Biot-Savart_law.html">
   27. Biot-Savart law
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L36_EM_radiation.html">
   28. Electromagnetic radiation
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/notebooks/L12_2D_collisions.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/dcartin/NAPS-Intermediate-Physics"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        <a class="edit-button" href="https://github.com/dcartin/NAPS-Intermediate-Physics/edit/master/notebooks/L12_2D_collisions.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/dcartin/NAPS-Intermediate-Physics/master?urlpath=tree/notebooks/L12_2D_collisions.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#d-collisions-in-the-cm-frame">
   2D collisions in the CM frame
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#an-imaginary-wall">
     An imaginary wall
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-general-case">
     The general case
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-perpendicular-unit-vector-in-vpython">
     The perpendicular unit vector in vPython
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#d-elastic-collisions-in-vpython">
   2D elastic collisions in vPython
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#calculations-for-2d-collisions">
   Calculations for 2D collisions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#from-the-computer-to-the-written-page">
     From the computer to the written page
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-find-final-speeds">
     Example: Find final speeds
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-smashing-particles">
     Example: Smashing particles
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary">
   Summary
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="two-dimensional-collisions">
<h1>Two-dimensional collisions<a class="headerlink" href="#two-dimensional-collisions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Up to this point, we have only talked about collisions along a line (1D collisions). There, we saw how to use the coefficient of restitution in the center of mass (CM) frame, along with the equations of relative motion, to find the results of a collision in the lab frame. These 1D collisions obey conservation of momentum, so this gives us another perspective on the process.</p>
<p>The question now is, how to extend this beyond colliding objects moving on the same line. These will be “glancing” collisions, where the two objects do not hit along the line connecting them, but instead “off to the side”. This will result in a force on each object accelerating them (for an instant!) in a different direction. For example, in the picture below, two spheres moving along the same line collide, but they do so such that the point of collision is not along the line they move. Thus, the two forces also point off at an angle. Remember that the forces give the directions of the <em>acceleration</em>, not the <em>final velocities</em> of the spheres!</p>
<p><img alt="Two spheres in a glancing collision, with the forces on each sphere" src="../_images/INT_AY21_L12_Fig01_Colliding_spheres_w_forces_small.png" /></p>
<p>Our plan for this lesson is the following. First, we will use the scalar product to help us extend what we did with 1D collisions to find the final velocities of two objects. Building off of this, we will program the physics of 2D collisions into a vPython simulation, where we have moving disks inside of a square box. Then, we can show that momentum is still conserved in these collisions. Finally, we will see how to use conservation of momentum to solve generic problems of 2D collisions.</p>
<p>Here are the objectives for this lesson:</p>
<ul class="simple">
<li><p>Explain how to use the scalar product to find the final velocity of an object after a 2D collision.</p></li>
<li><p>Use a procedure or function in Python to carry out part of a program.</p></li>
<li><p>Calculate the unknown mass or velocity of an object experiencing a collision in two dimensions using conservation of momentum.</p></li>
</ul>
</div>
<div class="section" id="d-collisions-in-the-cm-frame">
<h2>2D collisions in the CM frame<a class="headerlink" href="#d-collisions-in-the-cm-frame" title="Permalink to this headline">¶</a></h2>
<div class="section" id="an-imaginary-wall">
<h3>An imaginary wall<a class="headerlink" href="#an-imaginary-wall" title="Permalink to this headline">¶</a></h3>
<p>When we dealt with 1D collisions – where the initial and final velocities were along the same line – we used the coefficient of restitution <span class="math notranslate nohighlight">\(\epsilon\)</span> to measure the “springiness” of the collision (or its <em>elasticity</em>). Then, in the <em>CM frame</em>, we could define the final velocities of the two colliding objects <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(m_2\)</span> using</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, f} = -\epsilon {\vec v}_{1, i} \qquad
    {\vec v}_{2, f} = -\epsilon {\vec v}_{2, i}
\]</div>
<p>However, these equations do not quite work when you have glancing collisions. These collisions give final velocities that are not along the same line as the initial velocity, so <span class="math notranslate nohighlight">\({\vec v}_i\)</span> and <span class="math notranslate nohighlight">\({\vec v}_f\)</span> are <em>not</em> proportional as they were in 1D collisions. We can salvage something from this, though, since the <em>speeds</em> will be proportional! Let’s build up to this conclusion, one step at a time.</p>
<p>Hopefully, you remember from Lesson 08 (linear momentum and Newton’s laws) that if a ball hits a wall, the change in the ball’s velocity is perpendicular to the wall; this was one of the examples of that lesson.</p>
<p><img alt="Squash ball bouncing off of wall" src="../_images/INT_AY20_MP1_L19_Fig01_Ball_bouncing_off_wall_small.png" /></p>
<p>In that example, I snuck something past you – the result assumes that the collision is elastic, i.e. that <span class="math notranslate nohighlight">\(\epsilon = 1\)</span>! This came from the fact that the ball’s speed remained the same, just that the velocity changed directions. If the final speed had been less than the initial speed, then <span class="math notranslate nohighlight">\(\epsilon &lt; 1\)</span>. However, it gets more complicated to assume inelastic collisions, so let’s stick with elastic collisions.</p>
<p>Now let’s consider the case of two balls colliding, while looking in the CM frame. If I draw the collision as shown below, you can see that from the viewpoint of each of the colliding balls, it looks just like it has struck a wall.</p>
<p><img alt="Colliding spheres" src="../_images/INT_AY21_L12_Fig02_Colliding_spheres_w_forces_small.png" /></p>
<p>Suppose we define the <span class="math notranslate nohighlight">\(y\)</span> axis to be the vertical direction in this picture, with the <span class="math notranslate nohighlight">\(+x\)</span> direction to the right. Thus, each ball experiences a force along the <span class="math notranslate nohighlight">\(y\)</span> axis, and thus, this is the direction of their changes in velocity. Since we are assuming that the collision is elastic, then the initial and final velocities of the bottom mass <span class="math notranslate nohighlight">\(m_1\)</span> are given by</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, i} = v_{1, x} {\hat x} + v_{1, y} {\hat y} \qquad
    {\vec v}_{1, f} = v_{1, x} {\hat x} - v_{1, y} {\hat y}
\]</div>
<p>Note it is only the <span class="math notranslate nohighlight">\(y\)</span> component of the velocity that changes directions. This links up with the fact that the force on this mass is only in the <span class="math notranslate nohighlight">\(y\)</span> direction:</p>
<div class="math notranslate nohighlight">
\[
    \sum {\vec F}_1 = {\vec F}_{12} = m_1 \frac{\Delta {\vec v}_1}{\Delta t} = -\biggl( \frac{2m_1 v_y}{\Delta t} \biggr) {\hat y}
\]</div>
<p>A similar idea happens with the second mass, with only the <span class="math notranslate nohighlight">\(y\)</span> component of the velocity changing (from negative to positive, in this case).</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{2, i} = -v_{2, x} {\hat x} - v_{2, y} {\hat y} \qquad
    {\vec v}_{2, f} = -v_{2, x} {\hat x} + v_{2, y} {\hat y}
\]</div>
</div>
<div class="section" id="the-general-case">
<h3>The general case<a class="headerlink" href="#the-general-case" title="Permalink to this headline">¶</a></h3>
<p>To make this more general, though, let’s write the same velocities, but now in terms of parallel and perpendicular directions. Here, we think of an imaginary wall between the two spheres, so we can use our intuition from the collision of the ball and the wall from our previous example. Therefore “perpendicular” means towards or away from this wall, and “parallel” means along this wall.</p>
<p><img alt="Colliding spheres, with parallel and perpendicular unit vectors" src="../_images/INT_AY21_L12_Fig03_Colliding_spheres_w_unit_vec_small.png" /></p>
<p>This gives that</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, i} = v_{||} {\hat e}_{||} - v_\perp {\hat e}_\perp \qquad
    {\vec v}_{1, f} = v_{||} {\hat e}_{||} + v_\perp {\hat e}_\perp
\]</div>
<p>since <span class="math notranslate nohighlight">\({\hat e}_\perp = - {\hat y}\)</span>, so that the change in velocity is only in the perpendicular direction:</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, f} - {\vec v}_{1, i} = 2 v_\perp {\hat e}_\perp
\]</div>
<p>How do we find <span class="math notranslate nohighlight">\(v_\perp {\hat e}_\perp\)</span>? Well, the perpendicular direction (remember, this is perpendicular to the imaginary “wall” between the two spheres) points along the line between the centers of the two spheres. Thus, the way we have drawn it above, <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> points along the same line as the vector <span class="math notranslate nohighlight">\({\vec r}_1 - {\vec r}_2\)</span> between the two spheres. This is shown in the picture below. The vectors <span class="math notranslate nohighlight">\({\vec r}_1\)</span> and <span class="math notranslate nohighlight">\({\vec r}_2\)</span> are the position vectors of the sphere centers, measured from the origin <span class="math notranslate nohighlight">\(O\)</span>. The vector</p>
<div class="math notranslate nohighlight">
\[
    {\vec r}_{12} = {\vec r}_1 - {\vec r}_2
\]</div>
<p>is the relative position vector pointing <em>from</em> mass 2 <em>to</em> mass 1.</p>
<p><img alt="Position vectors for the two spheres, along with relative position vector " src="../_images/INT_AY21_L12_Fig05_Rel_pos_vectors_small.png" /></p>
<p>Thus, the unit vector <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> is the vector in the same direction as <span class="math notranslate nohighlight">\({\vec r}_{12}\)</span>, but with a unit magnitude. Remember this is found by taking the vector <span class="math notranslate nohighlight">\({\vec r}_{12}\)</span> and dividing by its magnitude.</p>
<div class="math notranslate nohighlight">
\[
    {\hat e}_\perp = \frac{{\vec r}_{12}}{r_{12}} = \frac{{\vec r}_1 - {\vec r}_2}{|{\vec r}_1 - {\vec r}_2|}
\]</div>
<p>So, once we find <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> using the position vectors of the two spheres, we can find <span class="math notranslate nohighlight">\(v_\perp {\hat e}_\perp\)</span> using the scalar product. Remember that, if</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, i} = v_{||} {\hat e}_{||} - v_\perp {\hat e}_\perp
\]</div>
<p>then taking the scalar product of this initial velocity with the unit vector <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> will give</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, i} \cdot {\hat e}_\perp = -v_\perp
\]</div>
<p>so that</p>
<div class="math notranslate nohighlight">
\[
    v_\perp {\hat e}_\perp = (-{\vec v}_{1, i} \cdot {\hat e}_\perp) {\hat e}_\perp
\]</div>
<p>Notice what is going on with the right-hand side: the part inside the parentheses gives the <em>scalar</em> velocity component <span class="math notranslate nohighlight">\(v_\perp\)</span>, while the unit vector <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> at the end gives the direction of this change in velocity.</p>
</div>
<div class="section" id="the-perpendicular-unit-vector-in-vpython">
<h3>The perpendicular unit vector in vPython<a class="headerlink" href="#the-perpendicular-unit-vector-in-vpython" title="Permalink to this headline">¶</a></h3>
<p>It might be a good time to see all of this math in action, so let’s create the situation above, where we have two spheres touching, and find the unit vector <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span>. Then we can use this unit vector to find the direction <em>at</em> one sphere, <em>away</em> from the other!</p>
<p>First, we need to import some vPython modules to make everything work. Remember that you saw the module <code class="docutils literal notranslate"><span class="pre">norm</span></code> in Lessons 06 (vector magnitude and direction) and 07 (projectile motion); this takes a vector <code class="docutils literal notranslate"><span class="pre">A</span></code> in vPython and finds the unit vector <code class="docutils literal notranslate"><span class="pre">norm(A)</span></code> in the same direction as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vpython</span> <span class="kn">import</span> <span class="n">arrow</span><span class="p">,</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="n">vector</span>
</pre></div>
</div>
</div>
</div>
<p>Now you will build off the skeleton code in the cell below to work through the math we did above.</p>
<blockquote>
<div><p><strong>Problem:</strong> Complete the code in the cell below, so that it shows two spheres, along with two arrows, each of which is at the center of one sphere and points away from the other. To do this, you need to perform the following steps:</p>
<ol class="simple">
<li><p>First, you need to create two spheres, <code class="docutils literal notranslate"><span class="pre">redBall</span></code> and <code class="docutils literal notranslate"><span class="pre">greenBall</span></code>, that have a radius <code class="docutils literal notranslate"><span class="pre">BALL_RADIUS</span></code> as defined. Uncomment the appropriate lines, and define <code class="docutils literal notranslate"><span class="pre">redBall.pos</span></code> and <code class="docutils literal notranslate"><span class="pre">greenBall.pos</span></code> so that the two spheres are just touching. You should do this <em>only</em> using the variable <code class="docutils literal notranslate"><span class="pre">BALL_RADIUS</span></code>, along with the necessary zeros!</p></li>
<li><p>The vector <code class="docutils literal notranslate"><span class="pre">relPos</span></code> represents the relative position vector <span class="math notranslate nohighlight">\({\vec r}_{RG} = {\vec r}_R - {\vec r}_G\)</span>, with <span class="math notranslate nohighlight">\({\vec r}_R\)</span> and <span class="math notranslate nohighlight">\({\vec r}_G\)</span> giving the positions of <code class="docutils literal notranslate"><span class="pre">redBall</span></code> and <code class="docutils literal notranslate"><span class="pre">greenBall</span></code> you just defined. Uncomment the assignment of <code class="docutils literal notranslate"><span class="pre">relPos</span></code>, and write in the necessary code to find <span class="math notranslate nohighlight">\({\vec r}_{RG}\)</span> in terms of <code class="docutils literal notranslate"><span class="pre">redBall.pos</span></code> and <code class="docutils literal notranslate"><span class="pre">greenBall.pos</span></code>.</p></li>
<li><p>Once you define the relative position vector <code class="docutils literal notranslate"><span class="pre">relPos</span></code>, the code for finding the unit vector <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> in the same direction is already in the cell. You may want to write a statement printing <code class="docutils literal notranslate"><span class="pre">perpUnit</span></code>, to make sure it is sensible.</p></li>
<li><p>Finally, you need to create the two arrows <code class="docutils literal notranslate"><span class="pre">redPerp</span></code> and <code class="docutils literal notranslate"><span class="pre">greenPerp</span></code>. The arrow <code class="docutils literal notranslate"><span class="pre">redPerp</span></code> is a unit vector with position at the center of <code class="docutils literal notranslate"><span class="pre">redBall</span></code>, and pointing <em>away</em> from <code class="docutils literal notranslate"><span class="pre">greenBall</span></code>. Uncomment the line defining <code class="docutils literal notranslate"><span class="pre">redPerp</span></code>, and write in the appropriate code for <code class="docutils literal notranslate"><span class="pre">redPerp.pos</span></code> and <code class="docutils literal notranslate"><span class="pre">redPerp.axis</span></code>. This should use only <code class="docutils literal notranslate"><span class="pre">redBall.pos</span></code> and <code class="docutils literal notranslate"><span class="pre">perpUnit</span></code>.</p></li>
<li><p>Do the same thing for <code class="docutils literal notranslate"><span class="pre">greenPerp</span></code>. Remember that this arrow should point in the <em>opposite</em> direction as <code class="docutils literal notranslate"><span class="pre">redPerp</span></code>!</p></li>
</ol>
</div></blockquote>
<blockquote>
<div><p><strong>Problem:</strong> Change the positions <code class="docutils literal notranslate"><span class="pre">redBall.pos</span></code> and <code class="docutils literal notranslate"><span class="pre">greenBall.pos</span></code>, so the spheres are still touching, but the line between them points in a different direction. Do your arrows <code class="docutils literal notranslate"><span class="pre">redPerp</span></code> and <code class="docutils literal notranslate"><span class="pre">greenPerp</span></code> still point away as before?</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">canvas</span><span class="p">()</span>

<span class="c1"># Definition</span>

<span class="n">BALL_RADIUS</span> <span class="o">=</span> <span class="mf">0.3</span>

<span class="c1"># Create two spheres</span>

<span class="c1">#redBall = sphere(pos = vector(#####), radius = BALL_RADIUS, color = color.red)</span>
<span class="c1">#greenBall = sphere(pos = vector(#####), radius = BALL_RADIUS, color = color.green)</span>

<span class="c1"># Find relative position vector r_RG = r_R - r_G</span>

<span class="c1">#relPos = </span>

<span class="c1"># Find perpendicular unit vector e_perp by finding</span>
<span class="c1"># unit vector along direction of vector relPos</span>

<span class="n">perpUnit</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">relPos</span><span class="p">)</span>

<span class="c1"># Draw unit vectors at center of each sphere</span>

<span class="c1">#redPerp = arrow(pos = #####, axis = #####, shaftwidth = 0.1)</span>
<span class="c1">#greenPerp = arrow(pos = #####, axis = #####, shaftwidth = 0.1)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="d-elastic-collisions-in-vpython">
<h2>2D elastic collisions in vPython<a class="headerlink" href="#d-elastic-collisions-in-vpython" title="Permalink to this headline">¶</a></h2>
<p>Let’s now look at this these 2D collisions in vPython. First, we need to import the usual modules.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vpython</span> <span class="kn">import</span> <span class="n">arrow</span><span class="p">,</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="n">vector</span>
</pre></div>
</div>
</div>
</div>
<p>We can put the necessary code for checking collisions in its own separate function <code class="docutils literal notranslate"><span class="pre">checkCollision()</span></code>. This is similar to code we have seen before: if the objects are too close together, we use relative motion to go to the CM frame, find the new velocities in that frame, then return back to the lab frame. However, we are adding in the ideas from above, using the “imaginary wall”, to figure out the final velocities of each object. So let’s go through this in detail. You should compare the description I am about to give to the code in the cell below, to make sure you know how everything matches up.</p>
<ol class="simple">
<li><p>The first thing to do is check if the two objects are close enough to collide. This <code class="docutils literal notranslate"><span class="pre">min_distance</span></code> would be twice the radius for two spheres, for example. If the objects do not collide, then the logical test in the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement is false, and the procedure does nothing.</p></li>
<li><p>Now, suppose the objects <em>do</em> collide. Remember from Lesson 09 (center of mass and collisions) that we need to be in the center of mass (CM) frame in order to use the coefficient of restitution. Thus, using the definition of <span class="math notranslate nohighlight">\({\vec v}_{CM}\)</span> from Lesson 09, we define <code class="docutils literal notranslate"><span class="pre">CM_vel</span></code>.</p></li>
<li><p>Using the relative motion equations (from Lesson 10), we can define the velocities <code class="docutils literal notranslate"><span class="pre">obj_1_CM_init_vel</span></code> of each object before the collision in the CM frame.</p></li>
<li><p>The next step is to use the imaginary wall idea from above. We define the unit vector <code class="docutils literal notranslate"><span class="pre">unit_perp</span></code> that points <em>from</em> object <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <em>towards</em> <code class="docutils literal notranslate"><span class="pre">obj1</span></code>. This is the unit vector <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> discussed previously. Then, we saw that</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, f} - {\vec v}_{1, i} = 2 v_\perp {\hat e}_\perp
\]</div>
<p>so that</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, f} = {\vec v}_{1, i} + 2 v_\perp {\hat e}_\perp
\]</div>
<p>Finally, using <span class="math notranslate nohighlight">\(v_\perp = -({\vec v}_{1, i} \cdot {\hat e}_\perp)\)</span>, we have an equation for the final velocity of object 1:</p>
<div class="math notranslate nohighlight">
\[
    {\vec v}_{1, f} = {\vec v}_{1, i} - 2({\vec v}_{1, i} \cdot {\hat e}_\perp) {\hat e}_\perp
\]</div>
<p>This is given in vPython by the definition of <code class="docutils literal notranslate"><span class="pre">obj1_CM_final_vel</span></code>. A similar logic is used to define <code class="docutils literal notranslate"><span class="pre">obj2_CM_final_vel</span></code>, just changing the initial velocity appropriately.
5. This gives the final velocities of each object in the CM frame; again using relative motion and the CM velocity, we can find the new velocities of each object in the lab frame. This is the final step of the process.</p>
<p>Make sure you run this cell before the next one, so the computer knows how to deal with collisions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">checkCollision</span><span class="p">(</span><span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span><span class="p">,</span> <span class="n">min_distance</span><span class="p">):</span>
    
    <span class="c1"># Are the two objects within the minimum distance?</span>
    
    <span class="k">if</span> <span class="n">mag</span><span class="p">(</span><span class="n">obj1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">obj2</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_distance</span><span class="p">:</span>
        
        <span class="c1"># Find CM velocity of objects</span>
        
        <span class="n">CM_vel</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj1</span><span class="o">.</span><span class="n">mass</span> <span class="o">*</span> <span class="n">obj1</span><span class="o">.</span><span class="n">velocity</span> <span class="o">+</span> <span class="n">obj2</span><span class="o">.</span><span class="n">mass</span> <span class="o">*</span> <span class="n">obj2</span><span class="o">.</span><span class="n">velocity</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">obj1</span><span class="o">.</span><span class="n">mass</span> <span class="o">+</span> <span class="n">obj2</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
        
        <span class="c1"># Transfer from lab frame to CM frame,</span>
        <span class="c1"># find CM frame velocities</span>
        
        <span class="n">obj1_CM_init_vel</span> <span class="o">=</span> <span class="n">obj1</span><span class="o">.</span><span class="n">velocity</span> <span class="o">-</span> <span class="n">CM_vel</span>
        <span class="n">obj2_CM_init_vel</span> <span class="o">=</span> <span class="n">obj2</span><span class="o">.</span><span class="n">velocity</span> <span class="o">-</span> <span class="n">CM_vel</span>
        
        <span class="c1"># Find new CM frame object velocities,</span>
        <span class="c1"># using perpendicular unit vector</span>
        
        <span class="n">unit_perp</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">obj1</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">obj2</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        
        <span class="n">obj1_CM_final_vel</span> <span class="o">=</span> <span class="n">obj1_CM_init_vel</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">obj1_CM_init_vel</span><span class="p">,</span> <span class="n">unit_perp</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_perp</span>
        <span class="n">obj2_CM_final_vel</span> <span class="o">=</span> <span class="n">obj2_CM_init_vel</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">obj2_CM_init_vel</span><span class="p">,</span> <span class="n">unit_perp</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_perp</span>
        
        <span class="c1"># Transfer from CM frame back to lab frame</span>
        
        <span class="n">obj1</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">obj1_CM_final_vel</span> <span class="o">+</span> <span class="n">CM_vel</span>
        <span class="n">obj2</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">obj2_CM_final_vel</span> <span class="o">+</span> <span class="n">CM_vel</span>
</pre></div>
</div>
</div>
</div>
<p>Let me make a short note here: this is rather sloppy code. I have used the fact I can get away with some bad programming practices with vPython to keep this code simple, but it is not really how you should write programs. You can ask me about this if you are interested, but if you decide to major in computer science, don’t come back to NAPS and berate me for my bad practices. I warned you.</p>
<p>Now that we have the collision checking procedure, you can run the following cell to show two colliding spheres. Each sphere has an initial position, velocity, and mass. Since the collision checking procedure is generic, you can play around with different masses and velocities, and see what the resulting collisions look like. Some interesting cases are spheres with the same mass or speed, or making the masses very different.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">canvas</span><span class="p">()</span>

<span class="c1"># Definitions</span>

<span class="n">RADIUS</span> <span class="o">=</span> <span class="mf">0.4</span>

<span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">DT</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">MAX_TIME</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># Create objects</span>

<span class="n">redBall</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">RADIUS</span><span class="p">,</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> \
                 <span class="n">mass</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">red</span><span class="p">,</span> <span class="n">make_trail</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">blueBall</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">RADIUS</span><span class="p">,</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> \
                 <span class="n">mass</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">blue</span><span class="p">,</span> <span class="n">make_trail</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Create velocity arrows</span>

<span class="n">redVel</span> <span class="o">=</span> <span class="n">arrow</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">redBall</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">redBall</span><span class="o">.</span><span class="n">velocity</span><span class="p">,</span> <span class="n">shaftwidth</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">blueVel</span> <span class="o">=</span> <span class="n">arrow</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">blueBall</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">blueBall</span><span class="o">.</span><span class="n">velocity</span><span class="p">,</span> <span class="n">shaftwidth</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Evolution loop</span>

<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">MAX_TIME</span><span class="p">:</span>
    <span class="n">rate</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    
    <span class="c1"># Check collisions using procedure</span>
    
    <span class="n">checkCollision</span><span class="p">(</span><span class="n">redBall</span><span class="p">,</span> <span class="n">blueBall</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">RADIUS</span><span class="p">)</span>
    
    <span class="c1"># Update positions</span>
    
    <span class="n">redBall</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">redBall</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">redBall</span><span class="o">.</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">DT</span>
    <span class="n">blueBall</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">blueBall</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">blueBall</span><span class="o">.</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">DT</span>
    
    <span class="c1"># Update velocity vectors</span>
    
    <span class="n">redVel</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">redBall</span><span class="o">.</span><span class="n">pos</span>
    <span class="n">redVel</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">redBall</span><span class="o">.</span><span class="n">velocity</span>
    
    <span class="n">blueVel</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">blueBall</span><span class="o">.</span><span class="n">pos</span>
    <span class="n">blueVel</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">blueBall</span><span class="o">.</span><span class="n">velocity</span>
    
    <span class="c1"># Update time</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="n">DT</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div id="glowscript" class="glowscript"></div></div><script type="application/javascript">if (typeof Jupyter !== "undefined") { window.__context = { glowscript_container: $("#glowscript").removeAttr("id")};}else{ element.textContent = ' ';}</script></div>
</div>
<blockquote>
<div><p><strong>Problem:</strong> Does the code in the last cell work when the two spheres are not moving along the same line? You should think about what it means to say that the code “works”!</p>
</div></blockquote>
<blockquote>
<div><p><strong>Problem:</strong> Does the code work if the spheres collide in <em>three</em> dimensions?</p>
</div></blockquote>
</div>
<div class="section" id="calculations-for-2d-collisions">
<h2>Calculations for 2D collisions<a class="headerlink" href="#calculations-for-2d-collisions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="from-the-computer-to-the-written-page">
<h3>From the computer to the written page<a class="headerlink" href="#from-the-computer-to-the-written-page" title="Permalink to this headline">¶</a></h3>
<p>This is a good point to collect everything we have done so far, and relate it to what is coming next. By thinking of the collision of two objects using the idea of an imaginary “wall”, we can find the final velocities of the objects after the collision. We should check that this collision conserves momentum; let’s reuse the picture of the two spheres to see this.</p>
<p><img alt="Colliding spheres, with parallel and perpendicular unit vectors" src="../_images/INT_AY21_L12_Fig03_Colliding_spheres_w_unit_vec_small.png" /></p>
<p>Since this is in the CM frame, we have that the total momentum is zero, or</p>
<div class="math notranslate nohighlight">
\[
    \sum {\vec p}_i = {\vec p}_{1, i} + {\vec p}_{2, i} = 0
\]</div>
<p>Writing this out in terms of the masses and initial velocities, we have</p>
<div class="math notranslate nohighlight">
\[
    m_1 (v_{1, ||} {\hat e}_{||} - v_{1, \perp} {\hat e}_\perp) + m_2 (-v_{2, ||} {\hat e}_{||} + v_{2, \perp} {\hat e}_\perp) = 0
\]</div>
<p>Combining the coefficients of the same unit vector, this is</p>
<div class="math notranslate nohighlight">
\[
    (m_1 v_{1, ||} - m_2 v_{2, ||}) {\hat e}_{||} + (-m_1 v_{1, \perp} + m_2 v_{2, \perp}) {\hat e}_\perp = 0
\]</div>
<p>Now remember what happens during the collision, seen in the CM frame. The parallel velocity components <span class="math notranslate nohighlight">\(v_{1, ||}\)</span> and <span class="math notranslate nohighlight">\(v_{2, ||}\)</span> are unaffected by the collision, just like the squash wall when it hit the wall. So, if the parallel momentum component was zero before the collision, it will be zero after. For the perpendicular parts, the collision just switches the signs of each of these – the objects move away from each other, rather than towards each other. Since both components switch signs, then if the perpendicular momentum component was zero before the collision, flipping the signs of both perpendicular velocity components will not change that.</p>
<p>That is what occurs in the CM frame, but what about the lab frame? Do we, as observers watching this process, see conservation of momentum as well? The answer is yes! Since the center of mass velocity is constant before and after the collision, the total momentum of the system is the total mass times that CM velocity (that is how we defined CM velocity in the first place!). So everything works out.</p>
<p>These are all the details of how collisions work, when thought of in terms of the relative motion of the two objects. However, since momentum is conserved throughout the collision, it is frequently more useful to just apply that idea to calculate unknown quantities. But it is always useful to bore down a bit, and understand the details of just <em>why</em> it all works. We will see this collision model again in Lesson 17 (fluids), when we use it to simulate the pressure of a fluid on the walls of its container. Thinking in terms of molecules as elastic spheres was crucial in developing a physical theory for gases.</p>
<p>Next, let’s work through two example problems of conservation of momentum for 2D collisions.</p>
</div>
<div class="section" id="example-find-final-speeds">
<h3>Example: Find final speeds<a class="headerlink" href="#example-find-final-speeds" title="Permalink to this headline">¶</a></h3>
<p>The drawing below shows a collision between two pucks on an air-hockey table. Puck A has a mass of 23.0 g and is moving along the <span class="math notranslate nohighlight">\(x\)</span> axis with a speed of 5.50 m/s. It makes a collision with puck B, which has a mass of 63.0 g and is initially at rest. The collision is not head-on. After the collision, the two pucks fly apart with the angles shown in the drawing. The final speed of puck A is 3.38 m/s. Find the final speed of puck B (in m/s).</p>
<p><img alt="Two colliding air-hockey pucks" src="../_images/INT_AY20_MP1_L31_Fig01-Colliding-pucks_small.png" /></p>
<p>To solve this problem, or any collision problem, our go-to method is momentum conservation. Thus, we start with the fact that the total momentum of the two-puck system stays the same before and after the collision.</p>
<div class="math notranslate nohighlight">
\[
    \sum {\vec p}_i = \sum {\vec p}_f
\]</div>
<p>If we write out what this means in terms of the momenta for pucks A and B, we have</p>
<div class="math notranslate nohighlight">
\[
    {\vec p}_{A, i} + {\vec p}_{B, i} = {\vec p}_{A, f} + {\vec p}_{B, f}
\]</div>
<p>Using <span class="math notranslate nohighlight">\({\vec p} = m {\vec v}\)</span> gives</p>
<div class="math notranslate nohighlight">
\[
    m_A {\vec v}_{A, i} + m_B {\vec v}_{B, i} = m_A {\vec v}_{A, f} + m_B {\vec v}_{B, f}
\]</div>
<p>Puck B is not moving before the collision, so <span class="math notranslate nohighlight">\({\vec v}_{B, i} = 0\)</span>.</p>
<p>Now, to solve this vector equation, we need to break it up into its <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> components. Remember that this is the same as taking the scalar product of the conservation of momentum equation with <span class="math notranslate nohighlight">\({\hat x}\)</span> for the <span class="math notranslate nohighlight">\(x\)</span> component, and similarly for the <span class="math notranslate nohighlight">\(y\)</span> component. Since there is no motion in the <span class="math notranslate nohighlight">\(z\)</span> direction, the <span class="math notranslate nohighlight">\(z\)</span> component of the total momentum is zero. This gives the two component equations</p>
<div class="math notranslate nohighlight">
\[
    x: m_A v_{A, ix} = m_A v_{A, fx} + m_B v_{B, fx} \qquad
    y: m_A v_{A, iy} = m_A v_{A, fy} + m_B v_{B, fy}
\]</div>
<p>Puck A is chosen to move along the <span class="math notranslate nohighlight">\(x\)</span> axis before the collision, so <span class="math notranslate nohighlight">\(v_{A, iy} = 0\)</span>. The figure shows the two directions for the final velocities; also, we know the final speed of puck A, and we are looking for the final speed of puck B. So it makes sense to use some trigonometry here, instead of writing the equations in terms of the velocity components. Using the vector diagrams</p>
<p><img alt="Vector diagrams for  and " src="../_images/INT_AY21_L12_Fig04_Vector_diagrams_small.png" /></p>
<p>we get that</p>
<div class="math notranslate nohighlight">
\[
    x: m_A v_{A, ix} = m_A v_{A, f} \cos \theta_A + m_B v_{B, f} \cos \theta_B\qquad
    y: 0 = m_A v_{A, f} \sin \theta_A - m_B v_{B, f} \sin \theta_B
\]</div>
<p>Notice that the <span class="math notranslate nohighlight">\(y\)</span> component of the final velocity <span class="math notranslate nohighlight">\({\vec v}_{B, f}\)</span> is negative, so there is a corresponding minus sign in that equation.</p>
<p>We are solving for the final speed <span class="math notranslate nohighlight">\(v_{B, f}\)</span>, which appears in both equations. Everything else in both equations is known, though, so we can really just pick one of the two, and solve for the unknown speed. Using the <span class="math notranslate nohighlight">\(y\)</span> equation, for example, gives</p>
<div class="math notranslate nohighlight">
\[
    v_{B, f} = \frac{m_A v_{A, f} \sin \theta_A}{m_B \sin \theta_B} = \biggl( \frac{m_A}{m_B} \biggr) \biggl( \frac{\sin \theta_A}{\sin \theta_B} \biggr) v_{A, f}
\]</div>
<p>I have grouped together like quantities in the last equation. From this, we can easily see that if the masses have the same units, then it doesn’t matter what they are, since they cancel out. Similarly, the units we use for <span class="math notranslate nohighlight">\(v_{A, f}\)</span> will be the same as those for the final answer <span class="math notranslate nohighlight">\(v_{B, f}\)</span>. Thus, we don’t have to convert from grams to kilograms when substituting here. In addition, we can see what happens if one mass is, say, four times the other, or the initial speed of puck A is halved. Algebraic equations can help answer questions like this easily without having to recalculate the entire problem.</p>
<p>Plugging in the given values gives <span class="math notranslate nohighlight">\(v_{B, f} = 1.86\)</span> m/s.</p>
</div>
<div class="section" id="example-smashing-particles">
<h3>Example: Smashing particles<a class="headerlink" href="#example-smashing-particles" title="Permalink to this headline">¶</a></h3>
<p>The drawing below shows a collision between two particles. The red particle has a mass of 200. g and is initially moving along the x-axis with a speed of 5.00 m/s. The blue particle has twice the mass of the red one and was initially at rest.  After the collision, the red particle moves off with a velocity of 4.00 m/s at an angle of 54.9<span class="math notranslate nohighlight">\(^\circ\)</span> CCW from the +x-axis. What is the speed (in m/s) and direction (<span class="math notranslate nohighlight">\(\theta_2\)</span>, or the angle CW from <span class="math notranslate nohighlight">\(+x\)</span> axis) of the blue particle after the collision?</p>
<p><img alt="Two colliding particles" src="../_images/INT_AY20_MP1_L33_Fig01-Colliding-particles_small.png" /></p>
<p>The initial setup of this problem is much like the last example – we set up the conservation of momentum equations for the situation, making them particular for this situation. Thus,</p>
<div class="math notranslate nohighlight">
\[
    \sum {\vec p}_i = \sum {\vec p}_f \Rightarrow {\vec p}_{1, i} = {\vec p}_{1, f} + {\vec p}_{2, f}
\]</div>
<p>The vector <span class="math notranslate nohighlight">\({\vec p}_{2, i} = 0\)</span>, since the second particle is initially at rest. Now we reach the point where we use a slightly different strategy than the last example. There, we knew the angle for puck B, so we could use trigonometry to write the momentum equations in terms of the unknown final speed <span class="math notranslate nohighlight">\(v_{2, f}\)</span>. Here, though, we don’t know either the final speed or direction of the second particle. We could still use trigonometry as before, but if you try it, it can get a little messy. There is a smarter method, which is to write the unknown velocity in terms of its <em>components</em>, rather than its magnitude and direction. I can still write the final velocity for the first particle, using the known speed and direction. This gives the two equations</p>
<div class="math notranslate nohighlight">
\[
    x: m_1 v_{1, ix} = m_1 v_{1, f} \cos \theta_1 + m_2 v_{2, fx} \qquad
    y: 0 = m_1 v_{1, f} \sin \theta_2 + m_2 v_{2, fy}
\]</div>
<p>These can be solved for the unknown velocity components as</p>
<div class="math notranslate nohighlight">
\[
    v_{2, fx} = \biggl( \frac{m_1}{m_2} \biggr) (v_{1, ix} - v_{1, f} \cos \theta_1) \qquad
    v_{2, fy} = - \biggl( \frac{m_1}{m_2} \biggr) v_{1, f} \sin \theta_2
\]</div>
<p>As we would expect, <span class="math notranslate nohighlight">\(v_{2, fy}\)</span> is negative, since it moves downward. As the previous problem, I have written the masses separately from the rest. We have that <span class="math notranslate nohighlight">\(m_1 / m_2 = 0.500\)</span>, since the blue mass <span class="math notranslate nohighlight">\(m_2\)</span> has twice the mass of the red one, so we didn’t even need to know the value of <span class="math notranslate nohighlight">\(m_1\)</span>!</p>
<p>Plugging in the given values, we calculate the components to be <span class="math notranslate nohighlight">\(v_{2, fx} = 1.350\)</span> m/s, and <span class="math notranslate nohighlight">\(v_{2, fy} = -1.636\)</span> m/s. Now, we can use the Pythagorean theorem to find the final speed, and the inverse tangent to find the direction. This gives a speed of 2.12 m/s, and an angle <span class="math notranslate nohighlight">\(\theta_2\)</span> (as given in the figure above) of <span class="math notranslate nohighlight">\(50.5^\circ\)</span>.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Before this lesson, we had talked about collisions and momentum conservation for 1D collisions. That featured the case where the point of collision was on the same line as the motion of the objects. Now, we have seen what happens when this is not true, for glancing collisions of two objects. This naturally leads to 2D motion after the collision. We have seen how this process works in two ways. The first was to focus on the collision itself, with a coordinate system of unit vectors <span class="math notranslate nohighlight">\({\hat e}_\perp\)</span> and <span class="math notranslate nohighlight">\({\hat e}_{||}\)</span>, based on the line between the two objects when they collide. We used this to find the final velocities of the objects, and constructed a vPython simulation. We will see the latter again as a model of a fluid in Lesson 17. Using this as another proof that conservation of momentum holds for these collisions, we then considered two example problems of solving analytically for the final velocities.</p>
<p>After this lesson, you should be able to:</p>
<ul class="simple">
<li><p>Explain how to find the final velocities of an object after an elastic 2D collision.</p></li>
<li><p>Explain how to use procedures and functions in Python.</p></li>
<li><p>Apply conservation of momentum to a 2D collision to solve for the unknown masses or velocities.</p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Daniel Cartin<br/>
        
            &copy; Copyright 2020-2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>