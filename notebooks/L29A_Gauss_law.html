
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gauss’ law &#8212; NAPS Intermediate Physics</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.c441f2ba0852f4cabcb80105e3a46ae6.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.7d483ff0a819d6edff12ce0b1ead3928.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  
  <h1 class="site-logo" id="site-title">NAPS Intermediate Physics</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../README.html">
   NAPS Intermediate Physics
  </a>
 </li>
</ul>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="L01_Introduction_to_Python.html">
   1. Introduction to Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L02_Vectors_and_vPython.html">
   2. Vectors and vPython
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L03_Velocity_and_Euler_method.html">
   3. Velocity and the Euler method
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L03A_Units_and_scientific_notation.html">
   4. Units and scientific notation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L04_Acceleration_and_free_fall.html">
   5. Acceleration and free fall
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L05_Kinematic_equations.html">
   6. Kinematic equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L06_Vector_magnitude_and_direction.html">
   7. Vector magnitude and direction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L07_Projectile_motion.html">
   8. Projectile motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L10_Relative_motion.html">
   9. Relative motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L08_Linear_momentum_and_Newton%27s_laws_of_motion.html">
   10. Linear momentum and Newton's laws of motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L09_Center_of_mass_and_collisions.html">
   11. Center of mass and collisions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L13_Solving_force_problems.html">
   12. Solving force problems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L11_Scalar_product.html">
   13. Scalar product
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L14_Inclined_planes.html">
   14. Inclined planes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L17_Fluids.html">
   15. Fluids
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L18_Circular_motion.html">
   16. Circular motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L19_Vector_product.html">
   17. Vector product
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L20_Angular_momentum.html">
   18. Angular momentum
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L23_Work_and_energy.html">
   19. Work and kinetic energy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L24_Conservation_of_energy.html">
   20. Conservation of energy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L25_Universal_gravitation.html">
   21. Universal gravitation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L26_Gravitational_potential_energy.html">
   22. Gravitational potential energy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L27_Kepler%27s_laws.html">
   23. Kepler's laws
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L28_Coulomb%27s_law.html">
   24. Coulomb's law
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L29_Electric_fields.html">
   25. Electric fields
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L34_Magnetic_fields_and_forces.html">
   26. Magnetic fields and forces
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L35_Biot-Savart_law.html">
   27. Biot-Savart law
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="L36_EM_radiation.html">
   28. Electromagnetic radiation
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/notebooks/L29A_Gauss_law.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/dcartin/NAPS-Intermediate-Physics"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        <a class="edit-button" href="https://github.com/dcartin/NAPS-Intermediate-Physics/edit/master/notebooks/L29A_Gauss_law.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>


            <!-- Full screen (wrap in <a> to have style consistency -->
            <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                    data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                    title="Fullscreen mode"><i
                        class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/dcartin/NAPS-Intermediate-Physics/master?urlpath=tree/notebooks/L29A_Gauss_law.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i>
            Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#electric-properties-of-materials">
   Electric properties of materials
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#electric-flux">
   Electric flux
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#counting-field-lines-through-a-surface">
     Counting field lines through a surface
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#an-example-of-electric-flux">
     An example of electric flux
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gauss-law-and-examples">
   Gauss’ law and examples
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Gauss’ law
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#an-example-a-single-point-charge">
     An example: a single point charge
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-single-charge-in-vpython">
     The single charge in vPython
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary">
   Summary
  </a>
 </li>
</ul>

        </nav>
        
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="gauss-law">
<h1>Gauss’ law<a class="headerlink" href="#gauss-law" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>In the last lesson, we looked at the idea of electric field lines. When Michael Faraday first developed the idea that eventually became the electric field, he had in mind physical “lines of force” that start and stop at electric charges. Specifically, he thought of a tube beginning at a positive charge, and ending at a negative charge. Although James Clerk Maxwell, and his successors, later formalized this into a more abstract idea, the idea of field lines is a helpful one for various physical situations.</p>
<p>Gauss’ law is one important example of the utility of thinking in this way. Remember that field lines point away from a positive charge. So, suppose we put this positive charge in a <em>closed</em> box (so that all field lines leaving the charge also go through the box), then all of the field lines that penetrate the surface of the box are pointing outward, away from the box’s interior. If we say every electric field line going through the box is positive if it leaves the box, then the net sum of all of the field lines is positive. Similarly, if we replace the positive charge with a negative one, the sum is now negative, since all of the field lines are going into the box and the negative charge.</p>
<p>Thus, thinking in terms of field lines gives us an intuition that there is a relationship between the amount of charge inside of a closed surface, and the amount of electric field going through the same surface. This is the content of Gauss’ law. This relation can be very powerful, allowing us to rather simply find the electric field magnitude around certain distributions of charge. In this lesson, we will make this process more formal, and show some examples of how to use it in practice. We will also build up these charge distributions in vPython simulations, so that we can see directly that Coulomb’s law – added up for many charges – indeed gives Gauss’ law.</p>
<p>Here are the objectives for this lesson:</p>
<ul class="simple">
<li><p>Define the concept of a gaussian surface.</p></li>
<li><p>State Gauss’ law for electrostatics.</p></li>
<li><p>Calculate the magnitude of the electric field for a symmetric charge distribution.</p></li>
</ul>
</div>
<div class="section" id="electric-properties-of-materials">
<h2>Electric properties of materials<a class="headerlink" href="#electric-properties-of-materials" title="Permalink to this headline">¶</a></h2>
<p>Before we get into the mathematics of Gauss’ law, it is first necessary to talk about the electrical properties of materials. In particular, we will divide substances into two broad categories: conductors and insulators. Although this is a rather broad (and inaccurate) brush, for conductors, at least, we are on fairly safe ground.</p>
<p>The basic dividing line between the two categories is how easy it is for electric charge to move inside the material. You can think it terms of attaching a particular object to a battery – if you try to send excess electrons through the object, will current actually flow? If the material is a conductor, then the answer is yes! A <strong>conductor</strong> is a substance where charges will freely move (or “conduct”) through the substance without hindrance. Most metals are conductors, which is why they are the material of choice for making electric wires. On the flip side are <strong>insulators</strong>, substances where electric charge is not free to move at all. These materials are used to insulate electric wires, so you don’t get shocked when you touch them! Examples include glass and rubber.</p>
<p>So why is this division useful for Gauss’ law? The key fact we will use quite a bit is what happens when an <em>external</em> electric field passes through a conductor. Imagine we place a piece of copper inside of a mechanism that creates electric fields. Because the charges are free to move inside the conducting copper, the electric field will create forces on these charges. Therefore, they will start moving around. However, eventually they will arrange themselves into positions where the net force on each charge is zero. This means that the charges inside the copper have moved to create their own, <em>internal</em>, electric field that cancels out the external field! This process is shown in the picture below, where the red positive charges and green negative charges will separate to create the internal field.</p>
<p><img alt="External fields through conductors cause internal charges to rearrange themselves until the external field is cancelled out" src="../_images/INT_AY20_MP3_L06_Fig03-Fields-inside-conductors.png" /></p>
<p>Since this internal electric field cancels out the external one – the charges are now at an equilibrium position – this means that the net electric field inside a conductor is zero. This is the key physical fact that we will use.</p>
<blockquote>
<div><p>The electric field inside of an ideal conductor is zero.</p>
</div></blockquote>
<p>This zero internal electric field is caused by charge moving to the surface of the conductor. Note that if the conductor has an <em>excess</em> charge, that charge will create its own (external) field! To see this, note that the charges in the picture above arranged themselves on the conductor’s surface in order to cancel out the external field. However, on the outside of the conductor the electric field lines still leave these surface charges.</p>
</div>
<div class="section" id="electric-flux">
<h2>Electric flux<a class="headerlink" href="#electric-flux" title="Permalink to this headline">¶</a></h2>
<div class="section" id="counting-field-lines-through-a-surface">
<h3>Counting field lines through a surface<a class="headerlink" href="#counting-field-lines-through-a-surface" title="Permalink to this headline">¶</a></h3>
<p>Now, let’s start developing the intuitive picture given above in the overview. Remember that, in a rough sense, we saw that the number of electric field lines going through a closed surface is related to the charge enclosed inside that surface. To make this sharper, we need to define some vectors related to an arbitrary surface.</p>
<p>Suppose there is a (flat) surface in a plane with some area <span class="math notranslate nohighlight">\(A\)</span>. Imagine a square tile on a bathroom floor, or a mat in front of a door. The <strong>normal vector</strong> <span class="math notranslate nohighlight">\({\hat n}\)</span> to this surface is a vector that points perpendicular to the plane of the surface. Note that we are using the word “normal” here in the same sense we did when we talked about the normal force. Something is normal if it is perpendicular to something else – just as the normal force is perpendicular to a surface, the normal vector is also perpendicular to the area in question. This vector <span class="math notranslate nohighlight">\({\hat n}\)</span> will point towards the “outside” when we have a closed surface; it will help us determine the direction of the electric field lines through the surface. Finally, the <strong>area vector</strong> <span class="math notranslate nohighlight">\({\vec A}\)</span> of the surface is a vector <span class="math notranslate nohighlight">\({\vec A}\)</span> with a magnitude equal to the area of the surface, and whose direction is given by the normal vector <span class="math notranslate nohighlight">\({\hat n}\)</span>.</p>
<p><img alt="The normal and area vectors for a square in the  plane" src="../_images/INT_AY20_MP3_L06_Fig01-Area-normal-vecs.png" /></p>
<p>We will now define “electric flux” <span class="math notranslate nohighlight">\(\Phi_E\)</span> as a way to quantify how many electric field lines pass through an area. If you think about what this means, we want to see how much of the electric field vector is perpendicular to the surface the field passes through. Thus, the angle between the electric field and the surface will matter. This is why I defined the area vector above! If the electric field is parallel to the <em>area vector</em>, then the field is perpendicular to the <em>surface</em>, and thus “through” the surface. However, if the electric field is perpendicular to the area vector, then the field does not go through the surface, but is instead “along” the surface. This generates zero electric flux through the surface.</p>
<p>Whenever we wanted to find how much of one vector was in the same direction as the other, we used the scalar product (Lesson 11) to find it. In other words, the scalar product of two vectors is larger when the angle between the vectors gets smaller. This is because, for two vectors <span class="math notranslate nohighlight">\({\vec C}\)</span> and <span class="math notranslate nohighlight">\({\vec D}\)</span>, the scalar product is given by their magnitudes <span class="math notranslate nohighlight">\(C, D\)</span>, and the angle <span class="math notranslate nohighlight">\(\theta_{CD}\)</span> between the vectors:</p>
<div class="math notranslate nohighlight">
\[
    {\vec C} \cdot {\vec D} = CD \cos \theta_{CD}
\]</div>
<p>Thus, we can define the <strong>electric flux</strong> through an surface of area <span class="math notranslate nohighlight">\(A\)</span> as the scalar product of the electric field <span class="math notranslate nohighlight">\({\vec E}\)</span> and the area vector <span class="math notranslate nohighlight">\({\vec A}\)</span> of the surface. Intuitively, we can say that there are “more field lines” passing through the surface when (1) there is a larger electric field or (2) a larger area, and (3) these two are aligned so the field lines pass through the surface.</p>
<ul class="simple">
<li><p><strong>Quantity:</strong> electric flux <span class="math notranslate nohighlight">\(\Phi_E\)</span></p></li>
<li><p><strong>Definition:</strong>
$<span class="math notranslate nohighlight">\(
  \Phi_E = {\vec E} \cdot {\vec A}
\)</span>$</p></li>
<li><p><strong>Units:</strong> N m<span class="math notranslate nohighlight">\(^2\)</span>/C</p></li>
</ul>
<p>You can see this in the figure below, which shows the extreme cases. On the left, the electric field lines pass directly through the blue surface. This means that the electric field is pointing in the same direction as the area vector, so there is zero angle between them, maximizing the flux. On the right, the electric field points along the surface, so none of the field lines actually go through the surface. Thus, the electric fiel <span class="math notranslate nohighlight">\({\vec E}\)</span> is perpendicular to the area vector <span class="math notranslate nohighlight">\({\vec A}\)</span>, and the scalar product is zero – there is no electric flux.</p>
<p><img alt="Maximum and mininum electric flux through a surface " src="../_images/INT_AY20_MP3_L06_Fig02-Max-min-flux.png" /></p>
<blockquote>
<div><p>{\bf Watch your angles!} One confusing point when finding the electric flux is how the direction of the electric field is given. For example, suppose the field is perpendicular to the surface. You might think this means the angle between <span class="math notranslate nohighlight">\({\vec E}\)</span> and <span class="math notranslate nohighlight">\({\vec A}\)</span> is then zero, but it’s not! That’s because the vector <span class="math notranslate nohighlight">\({\vec A}\)</span> is <em>also</em> perpendicular to the surface (because it is built from the normal vector). So if the field is perpendicular to the surface, that gives the maximum flux, since the field and area vectors point in the same direction. Be careful when you use your angles!</p>
</div></blockquote>
</div>
<div class="section" id="an-example-of-electric-flux">
<h3>An example of electric flux<a class="headerlink" href="#an-example-of-electric-flux" title="Permalink to this headline">¶</a></h3>
<p>Let’s work through an example. Suppose a large, flat conducting plate is placed in an external electric field <span class="math notranslate nohighlight">\({\vec E} = (500. \textrm{ mN/C}) {\hat x} + (700. \textrm{ mN/C}) {\hat y}\)</span>. A closed surface (indicated by the dashed lines) has <span class="math notranslate nohighlight">\(L = 1.20\)</span> m, <span class="math notranslate nohighlight">\(H = 6.00\)</span> m, and extends a distance of <span class="math notranslate nohighlight">\(W = 75.0\)</span> cm in the direction perpendicular to the screen. Exactly half of the surface is inside the plate in the <span class="math notranslate nohighlight">\(x\)</span> direction. We will find the electric flux through each of the six sides of the surface.</p>
<p><img alt="Closed surface placed partway into a conducting plate" src="../_images/img" /></p>
<p>You can see a three-dimensional representation of the situation in this example, you can run the following two cells. The first imports the necessary vPython modules.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vpython</span> <span class="kn">import</span> <span class="n">arrow</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">curve</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">vector</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we create both the (blue) conducting plate and the (gray) closed surface we will calculate the flux through. Yellow vectors represent the electric field passing through this surface, creating the flux. I also added a set of coordinate axes, so you can see the direction of the area vector for each of the six sides. Note that I only drew the field vectors through the surface, to avoid cluttering the visuals; this is not the only place the field actually is!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">canvas</span><span class="p">()</span>

<span class="c1"># Parameters for electric field vector arrows</span>

<span class="n">yStep</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">zStep</span> <span class="o">=</span> <span class="mf">0.75</span>

<span class="c1"># Size of closed surface (all in meters)</span>

<span class="n">L</span> <span class="o">=</span> <span class="mf">1.20</span>
<span class="n">H</span> <span class="o">=</span> <span class="mf">6.00</span>
<span class="n">W</span> <span class="o">=</span> <span class="mf">0.750</span>

<span class="c1"># Create closed surface</span>

<span class="n">surface</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">length</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">H</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">W</span><span class="p">,</span> <span class="n">opacity</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Create conducting plate</span>

<span class="n">plate</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">length</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">W</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">blue</span><span class="p">)</span>

<span class="c1"># Create coordinate axes</span>

<span class="n">curve</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">curve</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
     <span class="p">)</span>
<span class="n">label</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">label</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">label</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>

<span class="c1"># Create electric field vectors: the axis vector of</span>
<span class="c1"># these arrows is in the same ratio as the original</span>
<span class="c1"># field, so the direction of the field is accurate;</span>
<span class="c1"># the field vector locations are chosen for aesthetics</span>

<span class="k">for</span> <span class="n">yyy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">H</span> <span class="o">/</span> <span class="n">yStep</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">zzz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">W</span> <span class="o">/</span> <span class="n">zStep</span><span class="p">)):</span>
        <span class="n">arrow</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">H</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yStep</span> <span class="o">*</span> <span class="p">(</span><span class="n">yyy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">W</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">zStep</span> <span class="o">*</span> <span class="n">zzz</span><span class="p">),</span> \
              <span class="n">axis</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">shaftwidth</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">yellow</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we calculate the flux through the given surface. We will do this one side at a time; the descriptions of the surface sides are based on the default viewpoint given in the vPython simulation above. Starting with the right side, the normal vector points in the <span class="math notranslate nohighlight">\(+x\)</span> direction. The right side of the surface is at a constant <span class="math notranslate nohighlight">\(x\)</span> value, so it lies in the <span class="math notranslate nohighlight">\(y-z\)</span> plane. Going “outward” from the surface thus goes perpendicular to the surface, which is in the direction of increasing <span class="math notranslate nohighlight">\(x\)</span>. Multiplying the dimensions <span class="math notranslate nohighlight">\(H\)</span> in the <span class="math notranslate nohighlight">\(y\)</span> direction (up/down) and <span class="math notranslate nohighlight">\(W\)</span> in the <span class="math notranslate nohighlight">\(z\)</span> direction (into/out of screen), this gives an area vector of <span class="math notranslate nohighlight">\(HW {\hat x}\)</span>. Taking the scalar product of this with the electric field vector given previously, we have</p>
<div class="math notranslate nohighlight">
\[
    \Phi_{right} = {\vec E} \cdot {\vec A}_{right} = E_x HW = (0.500 \textrm{ N/C})(6.00 \textrm{ m})(0.750 \textrm{ m}) = +2.25 \textrm{ N m}^2/\textrm{C}
\]</div>
<p>Turning to the left side, notice that this side of the surface is completely inside the conducting surface. This means that the electric field through that surface is zero, so we can immediately say that <span class="math notranslate nohighlight">\(\Phi_{left} = 0\)</span>.</p>
<p>The remaining four sides are half in and half out of the conducting plate. This means that we only count half of the area of those sides; we will multiply each area vector by one-half to get the amount of area where a non-zero electric field exists. Think about which way you move when going from the inside to the outside of the closed surface to get the direction of the normal vector <span class="math notranslate nohighlight">\({\hat n}\)</span>, and thus the area vector <span class="math notranslate nohighlight">\({\vec A}\)</span>. In particular, running through the other sides,</p>
<p>\begin{eqnarray*}
\Phi_{top} &amp;=&amp;  {\vec E} \cdot [(1/2) LW (+{\hat y})] = (1/2) E_y LW = (0.5)(0.700 \textrm{ N/C})(1.20 \textrm{ m})(0.750 \textrm{ m}) = +0.315 \textrm{ N m}^2/\textrm{C} \
\Phi_{bottom} &amp;=&amp;  {\vec E} \cdot [(1/2) LW (-{\hat y})] = -(1/2) E_y LW = -(0.5)(0.700 \textrm{ N/C})(1.20 \textrm{ m})(0.750 \textrm{ m}) = -0.315 \textrm{ N m}^2/\textrm{C} \
\Phi_{front} &amp;=&amp;  {\vec E} \cdot [(1/2) LH (+{\hat z})] = 0 \
\Phi_{back} &amp;=&amp;  {\vec E} \cdot [(1/2) LH (-{\hat z})] = 0 \
\end{eqnarray*}</p>
<p>Let’s make a few comments here. For the top and bottom sides, all of the electric field that <em>enters</em> the surface at the bottom will <em>leave</em> the surface at the top, so these two fluxes have opposite signs – positive for leaving, and negative for entering field lines. For the front and the back, since the area vectors point along the <span class="math notranslate nohighlight">\(z\)</span> axis, and the electric field does not point in this direction, the fluxes are both zero.</p>
<blockquote>
<div><p><strong>Problem:</strong> A constant electric field of <span class="math notranslate nohighlight">\({\vec E}\)</span> = (-113 N/C) <span class="math notranslate nohighlight">\({\hat x}\)</span> + (90.3 N/C) <span class="math notranslate nohighlight">\({\hat y}\)</span> + (-28.4 N/C) <span class="math notranslate nohighlight">\({\hat z}\)</span> exists in a particular region. Consider a cubic surface whose center is at the origin, and whose sides are 10.0 cm in length, as shown in the figure below. Find the electric flux through each of the six sides of the cubic surface. <em>Answers:</em> -0.284 N m<span class="math notranslate nohighlight">\(^2\)</span>/C (top); 0.284 N m<span class="math notranslate nohighlight">\(^2\)</span>/C (bottom); 1.13 N m<span class="math notranslate nohighlight">\(^2\)</span>/C (left); -1.13 N m<span class="math notranslate nohighlight">\(^2\)</span>/C (right); 0.903 N m<span class="math notranslate nohighlight">\(^2\)</span>/C (near); 1.13 N m<span class="math notranslate nohighlight">\(^2\)</span>/C (far)</p>
<p><img alt="Cubic closed surface placed in an electric field" src="../_images/img" /></p>
</div></blockquote>
<p>Note that, for the previous example, the surface is closed – there are no holes in it! – and it also does not enclose any charge. Another way to say this latter point is that every electric field line entering the surface eventually leaves it; no field lines start or stop on charges inside the cube. This leads us to Gauss’ law, where we start putting charges inside closed surfaces.</p>
</div>
</div>
<div class="section" id="gauss-law-and-examples">
<h2>Gauss’ law and examples<a class="headerlink" href="#gauss-law-and-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Gauss’ law<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>We now have all the framework we need to state Gauss’ law. Remember that our intution is that the number of electric field lines going through a closed surface is proportional to the net amount of charge enclosed by that surface. For “number of field lines”, we will now say “electric flux” <span class="math notranslate nohighlight">\(\Phi_E\)</span>. We also need to have a closed surface, so that none of the field lines “escape” through holes in the surface. Thus, we give these surfaces a special name: a <strong>gaussian surface</strong> is a closed surface, i.e. with no holes or other boundaries.</p>
<p>So our intuitive idea now says that the electric flux through a gaussian surface is proportional to the net charge inside. We will call this net charge <span class="math notranslate nohighlight">\(Q_{enc}\)</span>, for the <em>enclosed</em> charge. Since the flux and <span class="math notranslate nohighlight">\(Q_{enc}\)</span> are proportional, there is a constant value that relates the two. The complete mathematical statement is given below.</p>
<blockquote>
<div><p><strong>Gauss’ law</strong>: The total charge <span class="math notranslate nohighlight">\(Q_{enc}\)</span> inside of a gaussian surface is related to the electric flux <span class="math notranslate nohighlight">\(\Phi_E\)</span> through the surface by</p>
<div class="math notranslate nohighlight">
\[ \Phi_E = \frac{Q_{enc}}{\epsilon_0} \]</div>
<p>where the constant <span class="math notranslate nohighlight">\(\epsilon_0\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[ \epsilon_0 = 8.85 \times 10^{-12} \textrm{ C}^2/\textrm{N m}^2\]</div>
</div></blockquote>
<p>Note that this constant <span class="math notranslate nohighlight">\(\epsilon_0\)</span> is just another way of expressing the constant <span class="math notranslate nohighlight">\(k\)</span> we saw in Lesson 28 (Coulomb’s law), since</p>
<div class="math notranslate nohighlight">
\[ k = \frac{1}{4 \pi \epsilon_0} \]</div>
</div>
<div class="section" id="an-example-a-single-point-charge">
<h3>An example: a single point charge<a class="headerlink" href="#an-example-a-single-point-charge" title="Permalink to this headline">¶</a></h3>
<p>We will see this now by treating the simplest case of Gauss’ law – namely, find the electric flux through a spherical surface of radius <span class="math notranslate nohighlight">\(R\)</span> due to a single point charge <span class="math notranslate nohighlight">\(Q\)</span> at its center. Going through this example, we will see the general procedure used to solve any Gauss’ law problem.</p>
<p>First, given a charge distribution, we find a gaussian surface that matches the symmetry of the problem; this makes the calculations much easier. What do I mean by “match the symmetry”? Well, think about a point charge sitting at the origin. If I revolve around the charge – meaning, if I move to another position, just with the same distance away from the charge – then the situation looks exactly the same. This means I should get the same answer for the electric field at this new position. What is a shape that looks the same if I move to any new position with the same radius? A sphere! Thus, a spherical gaussian surface matches the symmetry of a single point charge, in that the physics of the problem looks exactly the same when you are at the same radius from the charge.</p>
<p>Now we need to think about how to find the electric flux. We will do this by taking the total area <span class="math notranslate nohighlight">\(A_{sph}\)</span> of the sphere, and dividing it into little flat bits <span class="math notranslate nohighlight">\(\Delta A_i\)</span>; we are indexing each piece by a label <span class="math notranslate nohighlight">\(i\)</span>. Obviously, a sphere is not flat, so eventually we want to mathematically take the pieces of area to be as small as possible. In other words, we will take the limit <span class="math notranslate nohighlight">\(\Delta A_i \to 0\)</span>. For now, though, we are not going to worry about it. Since we chose flat pieces, then we can easily say what the direction of the normal vector <span class="math notranslate nohighlight">\({\hat n}\)</span> is for each piece (choosing the direction <em>away</em> from the center of the sphere). This means each flat bit has an area vector <span class="math notranslate nohighlight">\({\vec A}_i = (\Delta A_i) {\hat n}\)</span>.</p>
<p>We can also calculate the electric field <span class="math notranslate nohighlight">\({\vec E}_i\)</span> at the center of each piece <span class="math notranslate nohighlight">\(\Delta A_i\)</span>. Notice that the index <span class="math notranslate nohighlight">\(i\)</span> matches up; the electric fields will have different directions at difference area bits. This allows us to find the total electric flux through the sphere, by adding up the fluxes through each bit of area. Specifically, with the electric flux through an area <span class="math notranslate nohighlight">\(\Delta A_i\)</span> given by <span class="math notranslate nohighlight">\({\vec E}_i \cdot {\vec A}_i\)</span>, the sum is</p>
<div class="math notranslate nohighlight">
\[
    \Phi_E = \sum_i {\vec E}_i \cdot {\vec A}_i
\]</div>
<p>So what are these electric field vectors <span class="math notranslate nohighlight">\({\vec E}_i\)</span>? This is where choosing the sphere, to match the symmetry of the point charge, comes in handy. Since all of the areas have the same distance <span class="math notranslate nohighlight">\(R\)</span> away from the point charge, they all have the same magnitude <span class="math notranslate nohighlight">\(E_i\)</span>, namely</p>
<div class="math notranslate nohighlight">
\[ E_i = \frac{kQ}{R^2} \]</div>
<p>For the direction, since the point charge is at the origin, the position vector <span class="math notranslate nohighlight">\({\vec r}_i\)</span> of each area points directly away from the origin as well. Thus, the electric field at area <span class="math notranslate nohighlight">\(\Delta A_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[ {\vec E}_i = \frac{kQ}{R^2} {\hat r} \]</div>
<p>But this unit vector <span class="math notranslate nohighlight">\({\vec r}\)</span> is the same as the normal vector <span class="math notranslate nohighlight">\({\hat n}\)</span> for the area! Both point away from the origin, and both have magnitude one. Thus, since <span class="math notranslate nohighlight">\({\hat r} \cdot {\hat r} = 1\)</span>, if we find the electric flux through the piece of area <span class="math notranslate nohighlight">\(\Delta A_i\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[
    {\vec E}_i \cdot {\vec A}_i = \biggl( \frac{kQ}{R^2} {\hat r} \biggr) \cdot [(\Delta A_i) {\hat r}] = \biggl( \frac{kQ}{R^2} \biggr)(\Delta A_i)
\]</div>
<p>Note that the first piece of the last expression is constant everywhere on the sphere, so it can be factored out of the sum:</p>
<div class="math notranslate nohighlight">
\[
    \Phi_E = \sum_i {\vec E}_i \cdot {\vec A}_i = \biggl( \frac{kQ}{R^2} \biggr) \sum_i \Delta A_i = \biggl( \frac{kQ}{R^2} \biggr)(4 \pi R^2)
\]</div>
<p>In the last step, we used the fact that the sum of all the area pieces is just the surface area of a sphere, or <span class="math notranslate nohighlight">\(\sum_i \Delta A_i = A_{sph} = 4 \pi R^2\)</span>. Finally, we can cancel the <span class="math notranslate nohighlight">\(R^2\)</span> factors in numerator and denominator to give</p>
<div class="math notranslate nohighlight">
\[
    \Phi_E = 4 \pi k Q
\]</div>
<p>which equals <span class="math notranslate nohighlight">\(Q / \epsilon_0\)</span>, if we use the fact that <span class="math notranslate nohighlight">\(k = 1/(4 \pi \epsilon_0)\)</span>. It all works out!</p>
</div>
<div class="section" id="the-single-charge-in-vpython">
<h3>The single charge in vPython<a class="headerlink" href="#the-single-charge-in-vpython" title="Permalink to this headline">¶</a></h3>
<p>As we just saw, Gauss’ law holds for a single charge inside of a spherical gaussian surface. Because we used the symmetry of the problem, the calculations never got too complicated – we definitely weren’t using integral calculus anywhere! However, you may have a lingering doubt that I’ve pulled a fast one on you. After all, I put the charge exactly at the center of the sphere to do the calculation. But Gauss’ law says that the position does not matter, that you can put the point charge <em>anywhere</em> inside the sphere, and get the same answer! So what gives? Did I just pick the only case that works, or is Gauss’ law everything that is promised?</p>
<p>Well, doubt no more! Gauss’ law does, in fact, work whereever the point charge is inside the sphere. However, showing that mathematically requires the integral calculus that I didn’t use previously. To avoid this, I am going to have vPython numerically find the answer, and show that everything matches up. First, let’s import the necessary modules.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vpython</span> <span class="kn">import</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">cylinder</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">vector</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s outline what we are about to do in vPython code. This is going to repeat the basic process we saw above: divide the surface area of the sphere into small bits, find the electric flux through each area piece, then add all the contributions back together to get the total. This total should be equal to <span class="math notranslate nohighlight">\(Q / \epsilon_0\)</span>, according to Gauss’ law.</p>
<p>However, dividing the sphere into pieces of area can be tricky. To do this, I am going to use a pretty naive idea, but amazingly, it actually gives good results! This idea is to <em>randomly</em> place a bunch of flat disks around the sphere, so that the center of each disk is the same radius <span class="math notranslate nohighlight">\(R\)</span> away from the origin, and the sum of all the disk areas gives the total surface area of the sphere. You might think there are better ways to place the disks on the sphere, and there are, but like I said, this works, so let’s go with it.</p>
<p>There are a few details to work out. If we choose <span class="math notranslate nohighlight">\(N\)</span> flat disks of radius <span class="math notranslate nohighlight">\(r_{disk}\)</span>, then to have the sum of their areas be the same as the sphere’s surface area, then</p>
<div class="math notranslate nohighlight">
\[ N (\pi r^2 _{disk}) = 4 \pi R^2 \Rightarrow r_{disk} = \sqrt{\frac{4 R^2}{N}} = \frac{2 R}{\sqrt{N}} \]</div>
<p>where I pulled the <span class="math notranslate nohighlight">\(4 R^2\)</span> outside the square root. Each disk is going to be placed at a random location. To find this location, I pick a random position <span class="math notranslate nohighlight">\({\vec r}\)</span> with coordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span> inside the <em>cube</em> centered at the origin with side length 1. Then I find the unit vector <span class="math notranslate nohighlight">\({\hat r}\)</span> pointing in the same direction as that point. Notice this gives two vectors for the price of one – the center of the disk will be at <span class="math notranslate nohighlight">\(R {\hat r}\)</span>, and its normal vector <span class="math notranslate nohighlight">\({\hat n} = {\hat r}\)</span>!</p>
<p>The code for this placement process is given in the next code cell. The function <code class="docutils literal notranslate"><span class="pre">randomDisks()</span></code> places a number of random disks on the sphere. The arguements are the radius <code class="docutils literal notranslate"><span class="pre">R</span></code> of the sphere, and the number of disks <code class="docutils literal notranslate"><span class="pre">numDisks</span></code> to be placed. The results returned as a list of vPython cylinder objects.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">randomDisks</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">numDisks</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given the desired radius for the gaussian</span>
<span class="sd">    surface, create a list diskList of numDisks</span>
<span class="sd">    cylinder objects on this surface at random</span>
<span class="sd">    locations, where the total area of all disks</span>
<span class="sd">    is equal to the area of the sphere.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Find disk radius required so that the total</span>
    <span class="c1"># disk area is same as sphere area; create</span>
    <span class="c1"># list to store disks</span>
    
    <span class="n">diskRadius</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">numDisks</span><span class="p">)</span>
    <span class="n">diskList</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Create disks</span>
    
    <span class="k">for</span> <span class="n">iii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDisks</span><span class="p">):</span>
        <span class="n">randPos</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">diskList</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cylinder</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">randPos</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">randPos</span><span class="p">,</span> 
                    <span class="n">radius</span> <span class="o">=</span> <span class="n">diskRadius</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">blue</span><span class="p">,</span> <span class="n">emissive</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)]</span>
                    
    <span class="c1"># Return list of cylinder objects</span>
                    
    <span class="k">return</span> <span class="n">diskList</span>
</pre></div>
</div>
</div>
</div>
<p>Next, I create a seperate function <code class="docutils literal notranslate"><span class="pre">diskFlux()</span></code> to calculate the electric flux through each disk. The arguments of this function are a vPython cylinder object <code class="docutils literal notranslate"><span class="pre">disk</span></code> with <code class="docutils literal notranslate"><span class="pre">radius</span></code> and <code class="docutils literal notranslate"><span class="pre">axis</span></code> attributes, and a vPython vector <code class="docutils literal notranslate"><span class="pre">field</span></code> giving the electric field at the center <code class="docutils literal notranslate"><span class="pre">disk.pos</span></code> of the disk. Using this function simplifies the code a bit, since we will be doing this operation for all the disks. The function returns the scalar product of the area vector <span class="math notranslate nohighlight">\({\vec A}\)</span> and the electric field <span class="math notranslate nohighlight">\({\vec E}\)</span>, which is the electric flux through the disk.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">diskFlux</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a cylinder object, and the electric</span>
<span class="sd">    field at the center of this object, return</span>
<span class="sd">    the electric flux through the object, where</span>
<span class="sd">    the area vector is found using the axis</span>
<span class="sd">    attribute of the disk.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Find the area vector of the disk, and</span>
    <span class="c1"># take the scalar product with the given field</span>
    
    <span class="n">areaVec</span> <span class="o">=</span> <span class="p">(</span><span class="n">pi</span> <span class="o">*</span> <span class="n">disk</span><span class="o">.</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">disk</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">areaVec</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, I create a function <code class="docutils literal notranslate"><span class="pre">electricFlux()</span></code> to find the total electric flux. It takes a list <code class="docutils literal notranslate"><span class="pre">chargeList</span></code> of point charges, each of which has <code class="docutils literal notranslate"><span class="pre">pos</span></code> and <code class="docutils literal notranslate"><span class="pre">charge</span></code> attributes. The other arguments are the radius <code class="docutils literal notranslate"><span class="pre">R</span></code> of the sphere, and the number of disks <code class="docutils literal notranslate"><span class="pre">numDisks</span></code>. The default for the number of disks is chosen to be 100. The function returns the total electric flux calculated for the spherical gaussian surface.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">electricFlux</span><span class="p">(</span><span class="n">chargeList</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">numDisks</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of point charges (sphere objects</span>
<span class="sd">    with pos and charge attributes), find the</span>
<span class="sd">    electric flux through a spherical gaussian</span>
<span class="sd">    surface with given radius.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Physical parameter</span>
    
    <span class="n">k</span> <span class="o">=</span> <span class="mf">8.99E9</span>               <span class="c1"># electric constant(N m^2/C^2)</span>
    
    <span class="c1"># Initialize electric flux variable</span>
    
    <span class="n">elecFlux</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Create disks on surface</span>
    
    <span class="n">diskList</span> <span class="o">=</span> <span class="n">randomDisks</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">numDisks</span><span class="p">)</span>
    
    <span class="c1"># For each disk, calculate the electric field</span>
    <span class="c1"># at the center of the disk (taken as pos, since</span>
    <span class="c1"># the thickness of each disk is 0.01), and adds</span>
    <span class="c1"># this to the total electric flux</span>
    
    <span class="k">for</span> <span class="n">disk</span> <span class="ow">in</span> <span class="n">diskList</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pointCharge</span> <span class="ow">in</span> <span class="n">chargeList</span><span class="p">:</span>
            
            <span class="c1"># Find relative position vector</span>
            
            <span class="n">rVec</span> <span class="o">=</span> <span class="n">disk</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">pointCharge</span><span class="o">.</span><span class="n">pos</span>
            
            <span class="c1"># Find electric field at disk using</span>
            <span class="c1"># relative position vector, distance</span>
            
            <span class="n">elecField</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">pointCharge</span><span class="o">.</span><span class="n">charge</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">rVec</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">R</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Find disk contribution to total</span>
            <span class="c1"># electric flux</span>
            
            <span class="n">elecFlux</span> <span class="o">+=</span> <span class="n">diskFlux</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">elecField</span><span class="p">)</span>
            
    <span class="c1"># Return final electric flux value</span>
    
    <span class="k">return</span> <span class="n">elecFlux</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s now try out this code, by seeing if it agrees with the mathematical derivation we did earlier. The code cell below places a <span class="math notranslate nohighlight">\(+1.00 \ \mu\)</span>C charge at the origin, and finds the electric flux through a spherical gaussian surface of radius 1.00 m. If we use Gauss’ law, we expect that this flux will equal</p>
<div class="math notranslate nohighlight">
\[
    \Phi_E = \frac{Q}{\epsilon_0} = \frac{1.00 \times 10^{-6} \textrm{ C}}{8.85 \times 10^{-12} \textrm{ C}^2 / \textrm{N m}^2} = 1.13 \times 10^5 \textrm{ N m}^2 / \textrm{C}
\]</div>
<p>Run the code cell below, and see what the results are.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">canvas</span><span class="p">()</span>

<span class="c1"># Physical parameters</span>

<span class="n">e0</span> <span class="o">=</span> <span class="mf">8.85E-12</span>           <span class="c1"># epsilon naught</span>
<span class="n">Q</span> <span class="o">=</span> <span class="mf">1E-6</span>                <span class="c1"># unit of charge (C)</span>
<span class="n">R</span> <span class="o">=</span> <span class="mi">1</span>                   <span class="c1"># radius of gaussian surface</span>

<span class="c1"># Create list of charges</span>

<span class="n">chargeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">sphere</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">charge</span> <span class="o">=</span> <span class="n">Q</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">red</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)]</span>

<span class="c1"># Calculate electric flux</span>

<span class="n">electricFlux</span><span class="p">(</span><span class="n">chargeList</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Surprisingly, the random disk method works rather well! The number you get should be spot on with the theoretical value from Gauss’ law. Using random variables is actually common practice in a variety of fields, such as computer science, operations research, and data science. This simple method is known as the <strong>Monte Carlo method</strong>, after the famous casino town on the French Riviera.</p>
<p>However, this does not really answer the question that we started off with, namely, what if we move the charge? Change the position of the single point charge in <code class="docutils literal notranslate"><span class="pre">chargeList</span></code> above to <code class="docutils literal notranslate"><span class="pre">vector(0.1,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>, then run the cell again. You still get roughly the same answer. When I ran it with this position, I got <span class="math notranslate nohighlight">\(1.126 \times 10^5\)</span> N m<span class="math notranslate nohighlight">\(^2\)</span>/C, compared to the actual answer of <span class="math notranslate nohighlight">\(1.129 \times 10^5\)</span> N m<span class="math notranslate nohighlight">\(^2\)</span>/C, so only about a 0.3% error. Moving the charge to <code class="docutils literal notranslate"><span class="pre">vector(0.3,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> gives <span class="math notranslate nohighlight">\(1.097 \times 10^5\)</span> N m<span class="math notranslate nohighlight">\(^2\)</span>/C, so the error has grown to only 2.8% – still pretty good! Eventually, though, the error starts to build up, as you move the point charge further from the origin.</p>
<blockquote>
<div><p><strong>Problem:</strong> Change <code class="docutils literal notranslate"><span class="pre">chargeList</span></code> so that it includes two charges of opposite sign, but the same size charge (remember to make the negative one green!). Place one at <span class="math notranslate nohighlight">\(r_x = 0.3\)</span>, and the other at <span class="math notranslate nohighlight">\(r_x = -0.3\)</span>. Before you run the cell again, what value do you expect for the total electric flux? Now run the cell above, and see if you get the answer you expect. If its different, why might that be? Experiment with changing the positions of the two charges, and see how your results vary.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Gauss’ law is a powerful technique to find the electric field for a symmetric charge distribution. Whenever the physical situation looks the same when you rotate your perspective, or move along a line, then you can set up a gaussian surface that matches the symmetry. From this surface, you can choose the field that goes along with this symmetry, and rather easily solve for the magnitude of the field. Most of the hard mathematical work is done for you!</p>
<p>Although we do not discuss it here, there is a version of Gauss’ law for any force that obeys an inverse square law. This means there is a gravitational version of Gauss’ law, with similar properties to what we saw here: the number of gravitational field lines through a closed surface is proportional to the mass enclosed by the surface. The constant of proportionality will depend on <span class="math notranslate nohighlight">\(G\)</span> here, rather than <span class="math notranslate nohighlight">\(k\)</span>. Unlike the electrostatic force, however, there is no gravitational version of a “conductor”. This means that there is a gravitational field everywhere in the Universe, regardless of the location of any masses. By the way, this is the reason that <a class="reference external" href="https://www.ligo.org/">gravitational waves</a> are such a powerful new technique in astronomy – they pass through everything! Different kinds of electromagnetic waves (light) can be stopped by various kinds of matter, but a gravitational wave will go right through.</p>
<p>After this lesson, you should be able to:</p>
<ul class="simple">
<li><p>State the definition of electric flux.</p></li>
<li><p>State Gauss’ law.</p></li>
<li><p>Use Gauss’ law to find the electric field at a given position near a charge distribution.</p></li>
</ul>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Daniel Cartin<br/>
        
            &copy; Copyright 2020-2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>